# ğŸ”™[OpenGL](/docs/opengl/)

## æ‘„åƒæœº-ä¸–ç•Œè§‚å¯Ÿè€…
æ‘„åƒæœºåŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼š  
æŠ•å½±çŸ©é˜µProjection + ç…§ç›¸æœºçš„è½¬æ¢çŸ©é˜µView(å°†ä¸–ç•Œçš„ç‚¹è½¬æ¢åˆ°ä»¥è§†ç‚¹ä¸ºåŸç‚¹çš„åæ ‡ç³»ä¸­)


## æŠ•å½±çŸ©é˜µ
```
	é‡‡ç”¨äº†glmçš„å°è£…
    this->projection = glm::perspective(fov, aspect, zNear, zFar);
    å› ç´ ï¼š
    å¤¹è§’fov
    å®½é•¿æ¯”aspect
    è¿‘/è¿œè£å‰ªå¹³é¢ï¼ˆåŸºäºè§†ç‚¹çš„ æ‰€ä»¥æ€»ä¸ºæ­£æ•°ï¼‰
    ä¸€æ—¦è®¾å®š åŸºæœ¬æ¸¸æˆä¸­æ˜¯ä¸ä¼šæ”¹å˜çš„
```

## è§‚å¯ŸçŸ©é˜µ
```
	glm::lookAt(pos, pos + forward, up);
    å› ç´ ï¼š
    ä½ç½®pos
    æœå‰forward
    æœä¸Šup
    ä¸€èµ·å†³å®šäº†ç›¸æœºåœ¨ä¸–ç•Œä¸­çš„ä½ç½®å’Œæœå‘
    è‹¥æ‘„åƒæœºæœ‰ç§»åŠ¨ ä¼šå®æ—¶æ›´æ–°ç»™shader

    æŠ•å½±è§†å›¾çŸ©é˜µPV
    inline glm::mat4 GetViewProjection() const 
    {
        return projection * glm::lookAt(pos, pos + forward, up);
    }
```

## mainä¸­çš„ä½¿ç”¨
```
	Camera camera(glm::vec3(0, 0, -3), 70.0f, (float)WIDTH/(float)HEIGHT, 0.01, 1000.0f);
	shader.Update(transform, camera);
```
ä¼ ç»™shaderï¼šPV * M    ä»å³åˆ°å·¦ ä¸€èˆ¬éƒ½å«MVPçŸ©é˜µ
```
	glm::mat4 model = camera.GetViewProjection() * transform.GetModel();
	glUniformMatrix4fv(_uniforms[TRANSFORM_U], 1, GL_FALSE, &model[0][0]);
```










