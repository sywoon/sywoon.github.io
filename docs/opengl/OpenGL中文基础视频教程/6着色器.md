# ğŸ”™[OpenGL](/docs/opengl/)


## ç€è‰²å™¨
ä¸€ä¸ªç®€å•ç€è‰²å™¨ç±»Shader éœ€è¦çš„åŸºæœ¬ä¿¡æ¯
```
	static const unsigned int NUM_SHADERS = 2;
    GLuint _program;
    GLuint _shaders[NUM_SHADERS];
    GLuint _uniforms[NUM_UNIFORM];
```
ä¸€ä¸ªprogramå¯¹è±¡  ä¸¤ä¸ªshaderå¯¹è±¡  ä¸€ä¸ªuniformæ•°ç»„


## æå‰çŸ¥è¯†å‡†å¤‡
1. é”™è¯¯æ£€æµ‹ åˆ†ä¸ºprogramå’Œshader
```
	glGetProgramiv(shader, flag, &success);
    glGetShaderiv(shader, flag, &success);
    glGetProgramInfoLog(shader, sizeof(error), NULL, error);
    glGetShaderInfoLog(shader, sizeof(error), NULL, error);
    
    è·å–æŸä¸ªæ ‡è¯†çš„çŠ¶æ€ä¿¡æ¯  è‹¥æœ‰é—®é¢˜ å¯ä»¥è¿›ä¸€æ­¥è·å–logä¿¡æ¯
    éœ€è¦æ£€æµ‹çš„çŠ¶æ€ï¼š
    GL_COMPILE_STATUS
    GL_LINK_STATUS
    GL_VALIDATE_STATUS
```

2. åŠ è½½shaderæ–‡ä»¶
```
	std::ifstream file;
	file.open(fileName.c_str());
```
æ–¹æ³•å¾ˆå¤šç§  ä¸åŒå¼•æ“ä¸­éƒ½å°è£…äº†ä¸åŒçš„æ–‡ä»¶è¯»å–æ–¹å¼  
è¿™é‡Œç®€å•çš„é€šè¿‡ifstreamåº“è·å–æ•´ä¸ªæ–‡ä»¶å†…å®¹  


## å¼€å§‹åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„ç€è‰²å™¨ç±»
```
  åˆ›å»ºprogram  é€šè¿‡æ–‡ä»¶åˆ›å»ºshader
    _program = glCreateProgram();
    _shaders[0] = CreateShader(LoadShader(fileName + ".vs"), GL_VERTEX_SHADER);
    _shaders[1] = CreateShader(LoadShader(fileName + ".fs"), GL_FRAGMENT_SHADER);

  å°†shaderå¯¹è±¡å’Œprogramå…³è”
    for (unsigned int i = 0; i < NUM_SHADERS; i++)
    {
    glAttachShader(_program, _shaders[i]);
    }
    
  linkå‰ æŒ‡å®šç»‘å®šå±æ€§ç´¢å¼•å’Œåç§°
    glBindAttribLocation(_program, 0, "position");
    glBindAttribLocation(_program, 1, "texCoord");

    glLinkProgram(_program);
    CheckShaderError(_program, GL_LINK_STATUS, true, "Error:Program link failed");
    
  å¯ä»¥åªåœ¨debugç‰ˆæœ¬ä¸­åšéªŒè¯ 
    glValidateProgram(_program);
    CheckShaderError(_program, GL_VALIDATE_STATUS, true, "Error:Program validate failed");
    
  å…ˆè·å–uniformçš„åœ°å€ åé¢æ¸²æŸ“æ—¶å®æ—¶æ”¹å˜ æ¯”å¦‚mvpçŸ©é˜µå¯¹è±¡
    _uniforms[TRANSFORM_U] = glGetUniformLocation(_program, "transform");
```

## ææ„æ—¶éœ€è¦é‡Šæ”¾çš„å†…å®¹
```cpp
	for (unsigned int i = 0; i < NUM_SHADERS; i++)
    {
        glDetachShader(_program, _shaders[i]);
        glDeleteShader(_shaders[i]);
    }
    glDeleteProgram(_program);
```
å–æ¶ˆå…³è” + åˆ é™¤shader + åˆ é™¤program


## shaderçš„ä½¿ç”¨
```
	glUseProgram(_program);
```


## shaderçš„æ›´æ–°
```
	glm::mat4 model = camera.GetViewProjection() * transform.GetModel();
	glUniformMatrix4fv(_uniforms[TRANSFORM_U], 1, GL_FALSE, &model[0][0]);
```


## é¡¶ç‚¹ç€è‰²å™¨æ–‡ä»¶
```
	#version 120
    attribute vec3 position;
    attribute vec2 texCoord;

    varying vec2 texCoord0;
    uniform mat4 transform;

    void main()
    {
        gl_Position = transform * vec4(position, 1.0);
        texCoord0 = texCoord;
    }
```
é¡¶ç‚¹çš„mvpè½¬æ¢ + çº¹ç†åæ ‡  
ç®€åŒ–ç‰ˆæœ¬ï¼šåªæœ‰é¡¶ç‚¹ ç”¨é»˜è®¤çš„æŠ•å½±çŸ©é˜µ èŒƒå›´[-1,1]  
```
	#version 120
    attribute vec3 position;
    void main()
    {
        gl_Position = vec4(position, 1.0);
    }
```


## ç‰‡å…ƒç€è‰²å™¨æ–‡ä»¶
```
	#version 120
    uniform sampler2D diffuse;
    varying vec2 texCoord0;

    void main()
    {
        gl_FragColor = texture2D(diffuse, texCoord0);
    }
```
æ ¹æ®çº¹ç†åæ ‡ä»çº¹ç†ä¸­è¯»å–åƒç´ ä¿¡æ¯  
ç®€åŒ–ç‰ˆæœ¬:åªæœ‰ç‰‡å…ƒé¢œè‰²  
```
	#version 120
    void main()
    {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
```


## Mainä¸­ä½¿ç”¨shader
```
	Shader shader("res/basicShader");
    shader.Use();
    shader.Update(transform, camera);
    ... draw
    display.Update
```
æ¸²æŸ“å‰å…ˆä½¿ç”¨program  æ›´æ–°uniform  
![](6a.jpg)













